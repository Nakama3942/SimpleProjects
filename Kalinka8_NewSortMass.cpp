//*Это новая программа, которая сама генерирует объём массива, генерирует его значения, сортирует его, делает это десять раз, имеет 2 метода сортировки, который выбирает пользватель, а в конце ещё из последнего массива пользовательможет найти место данного элемента в массиве. Вот само задание:
//*===
//*Нужно создать массив (динамично), и вывести его на экран, используя при этом собственную функцию; Отсортировать массив, выбрав указанные методы и параметры сортировки; Запуская программу не меньше 10 раз для каждого метода (или предвидеть это в программе), задавать разное количество Н элементов массива и получить время Т сортировки; построить зависимость Т=Ф(Н) на одном графике для разных методов сортровки (в табличном и графическом видах); Сделать поиск указанного (с клавиатуры) элемента в массиве, используя укзанный метод поиска, относительно варианта. Вариант 3: Методы: Шелла, выбора; Тип: действительные; Направление: с конца; Порядок: по возрастанию; Поиск: бинарный.
//*===
//*Всё задание выполнено в этом коде.
//!Функция clock() возвращает время в тиках. Как я  выяснил на странице http://cppstudio.com/post/561/ :  значение, равное миллиону тиков соостветствует времени, равному одной секунде; т.е., чтобы найти время, затраченное на выполнение расчёта, нужно это количество тиков поделить на 1 000 000 и тогда мы получим время, относительно эквивалентоное секундам. В среднем, если эта программ тратит около 5000 тиков на сортировку, это равно 0,005 секунды.
//!У меня возникли проблемы с отображением времени. Я знаю, что получаю время в миллионных долях секунды. Грубо говоря, 98 тиков = 0,000098 секунды = 98 * 10^-6 секунды. -6 степень по приставкам таблицы СИ это микро- (https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%9F%D1%80%D0%B8%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B8_%D0%A1%D0%98). Следовательно 98 * 10^-6 секунды = 98 микро-секунды - это я и укажу.

#include <unistd.h> //Нужна для подключения функции sleep (значения указываются в секундах)
#include <iostream> //Нужна для ввода-вывода
#include <cstdlib>  //Подключаю библиотеку с функцией рандома
#include <ctime>    //Нужна для функции time и clock
#include <iomanip>
using namespace std;

//Функция вывода результата
void vyvod(float Massiv[], int Capacity)
{
    for (int p = 0; p < Capacity; p++)
    {
        //Текущие восемь элементов выводятся в строку, а следующие сношу на следующую
        if (p % 8 != 0)
            cout << "|___" << Massiv[p] << "__|";
        else
            cout << "\n|___" << Massiv[p] << "__|";
    }
}
//Функция сортировки методом Шелла
void sort1(float Massiv[], int Capacity)
{
    unsigned int Start_time = clock(); //Начальное время
    int shag = Capacity;
    while (shag > 0)
    {
        for (int n = 0; n < Capacity - shag; n++)
        {
            //Сравниваю элементы и выставляю меньший на первое место
            float *Menshee = &Massiv[n];
            float *Tekushee = &Massiv[n + shag];
            if (*Menshee > *Tekushee)
            {
                float Zamen = *Menshee;
                *Menshee = *Tekushee;
                *Tekushee = Zamen;
            }
        }
        shag /= 2;
    }
    unsigned int End_time = clock();                                            //Конечное время
    unsigned int Search_time = (End_time - Start_time);                         //Искомое время
    cout << "\n\nНовый массив = " << Capacity << " :\n";                        //Начинаю выводить массив
    vyvod(Massiv, Capacity);                                                    //Вывожу отсортированный массив
    cout << "\nВремя сортировки: " << Search_time << " микро-секунды (*10^-6)"; //Вывожу время сортировки
}
//Функция сортировки методом выбора
void sort2(float Massiv[], int Capacity)
{
    unsigned int Start_time = clock(); //Начальное время
    for (int Prosmotr = 0; Prosmotr < Capacity; Prosmotr++)
    {
        float *Menshee = &Massiv[Prosmotr];
        //Сравниваю первое число с каждым, и в конце первым должно стоять наименьшее. На каждый следующий круг будет оставаться всё меньше элементов
        for (int Prosm = Prosmotr + 1; Prosm < Capacity; Prosm++)
        {
            float *Tekushee = &Massiv[Prosm];
            if (*Menshee > *Tekushee)
            {
                float Zamen = *Menshee;
                *Menshee = *Tekushee;
                *Tekushee = Zamen;
            }
        }
    }
    unsigned int End_time = clock();                                            //Конечное время
    unsigned int Search_time = (End_time - Start_time);                         //Искомое время
    cout << "\n\nНовый массив = " << Capacity << " :\n";                        //Начинаю выводить массив
    vyvod(Massiv, Capacity);                                                    //Вывожу отсортированный массив
    cout << "\nВремя сортировки: " << Search_time << " микро-секунды (*10^-6)"; //Вывожу время сортировки
}
//Функция поиска
int BinarySearch(float Massiv[], float SearchEl, int Left, int Right)
{
    if (Right >= Left)
    {
        //Нахожу половину, в которой есть искомое число и каждый раз сужаю половину пополам. В конце должен вывестись номер элемента или -1
        int mid = (Right + Left) / 2;
        if (Massiv[mid] == SearchEl)
            return mid;
        if (Massiv[mid] > SearchEl)
            return BinarySearch(Massiv, SearchEl, Left, mid - 1);
        if (Massiv[mid] < SearchEl)
            return BinarySearch(Massiv, SearchEl, mid + 1, Right);
    }
    return -1;
}
//Функция генерации и сортировки массивов
void GenMass(int Vyzov)
{
    //Начинаю цикл, где будут генерироваться 10 раз массивы и сортироваться выбранным методом. В конце цикл спрашивает, какой элемнт хочет найти пользователь и вызывает функцию поиска.
    for (int p = 0; p < 10; p++)
    {
        srand(time(NULL)); //Беру текущее время для функции рандома
        //Создаю рандомно массив, который будет состоять из 2, 4, 8, 16, 32, 64, 128, 256 или 512 элементов
        int Capacity = 10 + rand() % 1000;
        for (int z = 2; z < Capacity * 2; z = z * 2)
            if (Capacity < z)
                Capacity = z;
        float Massiv[Capacity];
        //Генерирую для каждого элемента своё значение
        for (int i = 0; i < Capacity; i++)
        {
            float element = 10000 + rand() % 89999;
            Massiv[i] = element;
        }
        //Вывожу на экран начальный состав массива
        cout << "При количестве элементов " << Capacity << ", старый массив:\n";
        vyvod(Massiv, Capacity);
        sleep(1); //Ожидаю полсекунды перед сортировкой (измеряется в секундах)
        //Сортирую массив в зависимости от выбранного пользователем метода
        if (Vyzov == 1)
            sort1(Massiv, Capacity);
        else
            sort2(Massiv, Capacity);
        if (p < 9)
            cout << "\n\n\nПОВТОР ПРОГРАММЫ\n\n\n";
        sleep(3); //Заставляю ждать программу три секунды
        //Начинаю часть с сортировкой: пользователь вводит число, которое хочет найти...
        if (p == 9)
        {
            cout << "\n\nПрограмма выполнена 10 раз. Давайте в последнем массиве найдём нужное Вам число: ";
            float SearchEl;
            cin >> SearchEl;
            //... и вызывается функция поиска местонахождения числа в массиве
            cout << "Этот элемент находится на " << BinarySearch(Massiv, SearchEl, 0, Capacity - 1) + 1 << " месте.\n"; //Вывожу номер элемента
        }
    }
}
//Функция запрашивает метод сортировки
int ModeSort()
{
    cout << "\n\n\n__________\n\n\nПРОГРАММА ГЕНЕРАЦИИ, СОРТИРОВКИ МАССИВОВ И ПОИСКА ГЕОЛОКАЦИИ ЭЛЕМЕНТОВ В МАССИВЕ\n\n\n__________\n\n\n";
    int Vybor_sort, Vyzov = 0;
    bool Vyhod = 1;
    //Спрашиваю, как хочет пользователь отсортировать массив
    cout << "Выберите режим сортировки: Шелла(1) или выбором(2): ";
    do
    {
        cin >> Vybor_sort;
        switch (Vybor_sort)
        {
        case 1:
            Vyhod = 0;
            Vyzov = 1;
            break;
        case 2:
            Vyhod = 0;
            break;
        default:
            Vyhod = 1;
            cout << "Введено неправильное значение. Повторите попытку: ";
            break;
        }
    } while (Vyhod == 1);
    return Vyzov;
}
int main()
{
    GenMass(ModeSort());
    cout << "\n\n\n__________\n\n\nПРОГРАММА ВЫПОЛНЕНА\n\n\n__________\n\n"; //Вывод оповещения о завершении программы
    return 0;
}
