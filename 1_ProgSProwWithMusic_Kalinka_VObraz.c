//Программа, в которой просто присутствует много проверок для работы выходов и вообще
//введёных значений пользователей. В этой программе много комментариев, в которых много чего объясняется

#include <stdio.h>
#include <Windows.h> //Подключаю библиотеку с функциями настройки ввода-вывода

boolean ProverNomMuzZnak = 0; //Переменная, отвечающая за выход из цикла общения с пользователем; объявляю её глобальной

void FProverVyhod();

void main() {
	SetConsoleCP(1251); //Настраиваю ввод
	SetConsoleOutputCP(1251); //Настраиваю вывод

	int NomMuzZnak; //Переменная номера музыкального знака
	boolean Text = 0; //Переменная контролирующая цикл 16-18 строк

	printf("Введите номер нотного символа, а приложение выведет его название. Номер: ");

	do {
		/*Цикл if (Text == 1) {} не работает когда программа только запустилась, однако
		при дальнейшем использовании программы этот цикл будет всегда работать*/
		if (Text == 1) {
			printf("Номер: ");
		}
		Text = 1; //Включает цикл на 16-18 строчках

		fflush(stdin); //Обнуляем входной поток
		scanf("%i", &NomMuzZnak);

		/*Следующий Switch отвечает на ответ от пользователя. Его цель: вывести ответ и спросить, не хочет ли
		пользователь продолжить работу. В случае: неправильного ввода в начале, цикл начинается заново; если
		неправильно введено значение при ответе на продолжение работы, выбирается положительный ответ и цикл
		повторяется; при положительном ответе на продолжение работы цикл повторяется; и только при негативном
		ответе на продолжение работы цикл завершается. Этот процес регулируется булевыми переменными*/
		switch (NomMuzZnak) {
		case 1:
			printf("\nЭто До.\nХотите продолжить работу (1/0)? "); //Выводим результат и спрашиваем продолжение работы 
			//Дальше следует ввод ответа и проверка введёного ответа - для этого вызывается функция FProverVyhod
			FProverVyhod();
			break;
			/*Следующие кейсы от 2 до 7 аналогичны 1 за тем лишь отличием, что в строчке вывода будет
			отличаться выходной результат (не До, а, например, Ре или Ля)*/
		case 2:
			printf("\nЭто Ре.\nХотите продолжить работу (1/0)? ");
			FProverVyhod();
			break;
		case 3:
			printf("\nЭто Ми.\nХотите продолжить работу (1/0)? ");
			FProverVyhod();
			break;
		case 4:
			printf("\nЭто Фа.\nХотите продолжить работу (1/0)? ");
			FProverVyhod();
			break;
		case 5:
			printf("\nЭто Соль.\nХотите продолжить работу (1/0)? ");
			FProverVyhod();
			break;
		case 6:
			printf("\nЭто Ля.\nХотите продолжить работу (1/0)? ");
			FProverVyhod();
			break;
		case 7:
			printf("\nЭто Си.\nХотите продолжить работу (1/0)? ");
			FProverVyhod();
			break;
		default:
			/*Дефолт служит на случай неправильного ввода ответа на выбор ноты. Он сразу готовит цикл на
			повтор, чтобы пользователь мог повторно ввести данные*/
			ProverNomMuzZnak = 1; //установка повторения цикла
			printf("Введено неправильное значение, повторите попытку. ");
			break;
		}
	} while (ProverNomMuzZnak == 1); //условие повторения цикла (не выполняется только в случае отказа на продолжение работы)

	//В случае отказа от продолжения работы цикл завершается и следует завершение программы
	printf("Программа завершена.\n");
	system("pause");
}
void FProverVyhod() {
	int ProverVyhod; //Переменная проверки пользовательской инфо на ответ про выход
	fflush(stdin); // обнуляем входной поток
	scanf("%i", &ProverVyhod); //Пользователь вводит ответ на вопрос про выход
	//Дальше следует проверка введёного ответа
	switch (ProverVyhod) {
	case 0:
		ProverNomMuzZnak = 0; //Завершаем цикл
		break;
	case 1:
		ProverNomMuzZnak = 1; //Повторяем цикл
		break;
	default:
		printf("Введено неправильное значение. Подразумевается ввод значения 1.");
		ProverNomMuzZnak = 1; //Повторяем цикл
		break;
	}
}
